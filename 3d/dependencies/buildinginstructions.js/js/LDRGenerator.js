'use strict';

/**
   LDRGenerator defines the LDR.Generator namespace and is used for quick generation of LDraw primitives, such as simple circles, cylinders and discs.
   See https://www.ldraw.org/library/primref/ for an overview.
   Low-resolution primitives are not included since these are not used in parts.

   Main function is LDR.Generator.make, which results in a part type if it can be generated by the provided id.
 */

LDR.Generator = {
    make: function(id) {
        let sid = id.substring(0, id.length-4);

	// Traverse sid through path:
	let params = [];
	function find(i, cur) {
	    if(i == sid.length) {
		if(cur.hasOwnProperty('!'))
		    return cur['!'];
		return null;
	    }
	    let c = sid[i];
	    let isNum = false;

	    // Consider numbers as tokens:
	    if(c >= '0' && c <= '9') {
		let num = c-'0';
		while(i+1 < sid.length && (c = sid[i+1]) >= '0' && c <= '9') {
		    num = 10*num + (c-'0');
		    i++;
		}
		c = num;
		isNum = true;
	    }
	    
	    // Try direct match:
	    if(cur.hasOwnProperty(c)) {
		let ret = find(i+1, cur[c]);
		if(ret) {
		    return ret;
		}
	    }

	    // Try optional match:
	    if(cur.hasOwnProperty('?') && isNum) {
		cur = cur['?'];
		params.push(c);
		let ret = find(i+1, cur);
		if(ret) {
		    return ret;
		}
		params.pop(); // Not a match. Deregister the parameter.
	    }
	    
	    return null; // No match!
	}

	let builder = find(0, this.path);
	if(!builder) {
	    return null;
	}
	
	// Build the part type:
	let pt = builder(...params);
	pt.ID = pt.name = id;
	return pt;
    },
    register: function(path, f) {
	let cur = this.path;
	for(let i = 0; i < path.length; i++) {
	    let c = path[i];

	    // Consider numbers as tokens:
	    if(c >= '0' && c <= '9') {
		let num = c-'0';
		while(i+1 < path.length && (c = path[i+1]) >= '0' && c <= '9') {
		    num = 10*num + (c-'0');
		    i++;
		}
		c = num;
	    }
	    
	    if(cur.hasOwnProperty(c)) {
		cur = cur[c];
	    }
	    else {
		cur = (cur[c] = {});
	    }
	}
	cur['!'] = f; // ! used as it never occurs in a file name.
    },
    pad2: x => (x < 10 ? ' ' : '') + x,
    pT: function(desc) {
        let pt = new THREE.LDRPartType();

        pt.modelDescription = desc;
        pt.author = 'LDRGenerator.js';
        pt.license = 'Redistributable under CCAL version 2.0 : see CAreadme.txt';
        pt.inlined = 'GENERATED';
        pt.ldraw_org = 'Primitive';
        pt.cleanSteps = pt.certifiedBFC = pt.CCW = pt.isPart = true;

        let s = new THREE.LDRStep();
        pt.steps.push(s); // No need to user 'addStep()' for primitives.

        return [pt,s];
    },
    R: function(a, b) {
        let ret = new THREE.Matrix3();
        ret.set(a, 0, 0, 0, b, 0, 0, 0, a);
        return ret;
    },
    R2: function(a, b, c) {
        let ret = new THREE.Matrix3();
        ret.set(0, 0, a, 0, b, 0, c, 0, 0);
        return ret;
    },
    f2s: function(f) {
        if(f === parseInt(f+'')) {
            return f + '.0';
        }
        return f;
    },
    V: (x,y,z) => new THREE.Vector3(x,y,z),
    empty: function(id = 'Empty') {
        let [pt,ignore] = this.pT(id);
        pt.steps = [];
        return pt;
    },
    alias: function(to) {
        let [pt,s] = this.pT('~Moved to ' + to.replace('/', '\\'));
        s.asm(null, null, to);
        pt.replacement = to + '.dat';
        return pt;
    },
    eAlias: function(n = '~Obsolete file') {
        let [pt,s] = this.pT(n);
        s.asm(null, null, 'empty');
        pt.replacement = 'empty.dat';
        return pt;
    },
    cs: (i, div=8) => [Math.cos(i*Math.PI/div),  Math.sin(i*Math.PI/div)],


    co: function(N, D, M = 1, disc = false) {
        let [pt,s] = this.pT((M > 1 ? 'Hi-Res ' : '') + 'Cylinder ' + (disc ? 'Closed' : 'Open') + ' ' + this.f2s(N/D));
        let p0 = this.V();
        let p1 = this.V(0, 1, 0);
        let r = this.R(1, 1);

        let P = (M > 1 ? '48\\' : '')+N+'-'+D;
        s.asm(p0, r, P+'cyli');
        s.asm(p0, r, P+'edge');
        s.asm(p1, r, P+'edge');
        if(disc) {
            s.asm(p0, r, P+'disc');
        }
        return pt;
    },
    co48: function(N, D) {let p = this.co(N, D, 3); p.ldraw_org = '48_Primitive'; return p;},
    cc: function(N, M = 1) {return this.co(N, 4, M, true);},
    cc48: function(N) {let p = this.cc(N, 3); p.ldraw_org = '48_Primitive'; return p;},
    ccX: function(N, M = 1, V = 2, Q = '') {
        let [pt,s] = this.pT((M > 1 ? 'Hi-Res ' : '') + 'Cylinder Closed ' + Q + this.f2s(N/4) + ' without ' + (V === 2 ? 'Edges and Conditional' : 'Top or Bottom Edge') + ' Lines');
        let p = this.V();
        let r = this.R(1, 1);

        let P = (M > 1 ? '48\\' : '')+N+'-'+4;
        s.asm(p, r, P+'disc');
        s.asm(p, r, P+'cyli' + V);
        return pt;
    },
    ed: function(N, D, M = 1) {
        let [pt,S] = this.pT((M > 1 ? 'Hi-Res ' : '') + 'Circle ' + this.f2s(N/D));
        let prev = this.V(1, 0, 0);
        for(let i = 1; i <= M*16/D*N; i++) {
            let [c,s] = this.cs(i, 8*M);
            let p = this.V(c, 0, s);
            S.addLine(24, prev, p);
            prev = p;
        }
        return pt;
    },
    e48: function(N, D) {let p = this.ed(N, D, 3); p.ldraw_org = '48_Primitive'; return p;},
    cy: function(N, D, y = 1, C = 0.4141, M = 1) { // y is for control points
        let [pt,S] = this.pT('Cylinder ' + this.f2s(N/D));

        let p0 = this.V(1, 0, 0), p1 = this.V(1, 1, 0);
        let [c,s] = this.cs(1);
        let next0 = this.V(c, 0, s);
        let next1 = this.V(c, 1, s);

        if(N < D) { // Add conditional line in beginning:
            if(y) {
                S.addConditionalLine(24, p0, p1, next1, this.V(1, 1, -C)); // First tangest line at y=1 of length 0.4142
            }
            else {
                S.addConditionalLine(24, p0, p1, next0, this.V(1, 0, -1)); // First tangent line at y=0 of length 1
            }
        }
        let prev0, prev1;
        for(let i = 2; i < M*N*16/D + 2; i++) {
            prev0 = p0;
            prev1 = p1;
            p0 = next0;
            p1 = next1;
            [c,s] = this.cs(i, 8*M);
            next0 = this.V(c, 0, s);
            next1 = this.V(c, 1, s);

            S.addQuad(16, prev1, p1, p0, prev0);

            if(y) {
                if(N < D && i === M*N*16/D + 1) { // Last conditional line aligns with tangent. Thanks Magnus! https://forums.ldraw.org/thread-24262-post-39360.html
                    let tangent = this.V(); tangent.subVectors(next1, prev1); tangent.setLength(C);
                    next1.addVectors(p1, tangent);
                }
                S.addConditionalLine(24, p0, p1, next1, prev1);
            }
            else {
                if(N < D && i === M*N*16/D + 1) { // Inconsistent cases:
                    next0 = this.V(-c, 0, s);
                    prev0 = this.V(-1, 0, 1);
                }
                S.addConditionalLine(24, p0, p1, next0, prev0);
            }
        }
        return pt;
    },
    c48: function(N, D) {let p = this.cy(N, D, 1, 0.4141, 3); p.ldraw_org = '48_Primitive'; return p;},
    cy2: function(N, D, M = 1) {
        let [pt,S] = this.pT((M > 1 ? 'Hi-Res ' : '') + 'Cylinder ' + this.f2s(N/D) + ' without Conditional Lines');

        for(let i = 0; i < M*N*16/D; i++) {
            let [c1,s1] = this.cs(i, 8*M);
            let [c2,s2] = this.cs(i+1, 8*M);
            S.aq([c2, 1, s2, c2, 0, s2, c1, 0, s1, c1, 1, s1]);
        }
        return pt;
    },
    cy2_48: function(N, D) {let p = this.cy2(N, D, 3); p.ldraw_org = '48_Primitive'; return p;},
    con0: function(N, D = 4) {
        let [pt,S] = this.pT('Cone  0 x ' + this.f2s(N/D));

        const P = this.V(0, 1, 0);
        let p = this.V(1, 0, 0);
        let [c,s] = this.cs(1);
        let next = this.V(c, 0, s);
        let prev = (N === 2) ? this.V(c, 0, -s) : this.V(1, 0, -.3);

        if(N < D) {
            S.addConditionalLine(24, P, p, next, prev);
        }
        for(let i = 2; i < N*16/D + 2; i++) {
            prev = p;
            p = next;
            [c,s] = this.cs(i);
            next = this.V(c, 0, s);

            S.addTriangle(16, P, p, prev);
            S.addConditionalLine(24, P, p, next, prev);
        }
        if(N*2 < D) {
            if(D === 8) {
                next.set(.495, 0, .9192);
            }
            else {
                next.set(-.3, 0, 1);
            }
        }
        return pt;
    },
    con: function(N, D, r, x1, z1, x2, z2) {
        let [pt,S] = this.pT('Cone ' + this.pad2(r) + ' x ' + this.f2s(N/D));
        const R = r+1;
        
        let p1 = this.V(r, 1, 0), p0 = this.V(R, 0, 0);
        let [c,s] = this.cs(1);
        let next0 = this.V(R*c, 0, R*s), next1 = this.V(r*c, 1, r*s);
        let prev1 = this.V(x1, 1, z1);

        if(N < D) {
            S.addConditionalLine(24, p1, p0, next1, prev1);
        }
        for(let i = 2; i < N*16/D + 2; i++) {
            let prev0 = p0;
            prev1 = p1;
            p0 = next0;
            p1 = next1;
            [c,s] = this.cs(i);
            next1 = this.V(r*c, 1, r*s);
            next0 = this.V(R*c, 0, R*s);

            S.addQuad(16, p0, prev0, prev1, p1);
            S.addConditionalLine(24, p1, p0, next1, prev1);
        }
        if(N < D) {
            next1.set(x2, 1, z2);
        }
        return pt;
    },
    cylSloped: function(N, lastNext) {
        let [pt,S] = this.pT('Cylinder Sloped ' + this.f2s(N*.25));

        let p0 = this.V(1, 0, 0), p1 = this.V(1, 0, 0);
        let [c,s] = this.cs(1);
        let next0 = this.V(c, 0, s);
        let next1 = this.V(c, 1-c, s);

        for(let i = 2; i < 4*N+2; i++) {
            let prev0 = p0, prev1 = p1;
            p0 = next0;
            p1 = next1;
            [c,s] = this.cs(i);
            next0 = this.V(c, 0, s);
            next1 = this.V(c, 1-c, s);

            if(i === 2) {
                S.addTriangle(16, prev1, p1, p0);
            }
            else if(i === 17) {
                S.addTriangle(16, prev1, p1, prev0);
            }
            else {
                S.addQuad(16, prev1, p1, p0, prev0);
            }

            if(p0.y !== p1.y) {
                S.addConditionalLine(24, p0, p1, prev0, next0);
            }
        }
        if(lastNext) {
            next0.copy(lastNext);
        }

        return pt;
    },
    disc: function(N, D, M = 1) {
        let [pt,S] = this.pT((M > 1 ? 'Hi-Res ' : '') + 'Disc ' + this.f2s(N/D));
        let zero = this.V(0, 0, 0);
        let prev = this.V(1, 0, 0);
        for(let i = 1; i <= M*N*16/D; i++) {
            let [c,s] = this.cs(i, 8*M);
            let p = this.V(c, 0, s);
            S.addTriangle(16, zero, prev, p);
            prev = p;
        }
        return pt;
    },
    d48: function(N, D) {let p = this.disc(N, D, 3); p.ldraw_org = '48_Primitive'; return p;},
    nd: function(N, D, M = 1) {
        let [pt,S] = this.pT((M > 1 ? 'Hi-Res ' : '') + 'Disc Negative ' + this.f2s(N/D));
        let X = [this.V(1, 0, 1), this.V(-1, 0, 1), this.V(-1, 0, -1), this.V(1, 0, -1)];
        let prev = this.V(1, 0, 0);
        for(let i = 1; i <= M*N*16/D; i++) {
            let [c,s] = this.cs(i, 8*M);
            let p = this.V(c, 0, s);
            S.addTriangle(16, X[parseInt((i-1)/(M === 1 ? 4 : 16))], p, prev);
            prev = p;
        }
        return pt;
    },
    n48: function(N, D) {let p = this.nd(N, D, 3); p.ldraw_org = '48_Primitive'; return p;},
    chrd: function(N, D) {
        let [pt,S] = this.pT('Chord ' + this.f2s(N/D));
        let prevX = 1, prevY = 0;
        for(let i = 1; i <= N*16/D; i++) {
            let [c,s] = this.cs(i);
            let p = this.V(c, 0, s);
            if(i === 1) {
                S.at(16, X[parseInt((i-1)/4)], p, prev);
            }
            
            prev = p;
        }
        return pt;
    },
    ri: function(N, D, size, M = 1, ERROR_NAME = false) {
        let [pt,S] = this.pT(ERROR_NAME ? ERROR_NAME : (M > 1 ? 'Hi-Res ' : '') + 'Ring ' + this.pad2(size) + ' x ' + this.f2s(1.0/D*N));
        let SIZE = size+1;
        let prev1 = this.V(size, 0, 0);
        let prev2 = this.V(SIZE, 0, 0);
        for(let i = 1; i <= M*16/D*N; i++) {
            let [c,s] = this.cs(i, 8*M);
            let p1 = this.V(SIZE*c, 0, SIZE*s);
            let p2 = this.V(size*c, 0, size*s);
            S.addQuad(16, prev2, p1, p2, prev1);
            prev1 = p2;
            prev2 = p1;
        }
        return pt;
    },
    r48: function(N, D, size) {let p = this.ri(N, D, size, 3); p.ldraw_org = '48_Primitive'; return p;},
    stug: function(X, Y, suffix = '', sub = 1) {
        const NAMES = {'':'',
                       '2':'Open ',
                       '3':'Tube Solid ',
                       '4':'Tube Open ',
                       'p01':'with Dot Pattern '};
        let [pt,s] = this.pT('Stud ' + NAMES[suffix] + 'Group ' + this.pad2(X) + ' x ' + this.pad2(Y));

        for(let x = 0; x*sub < X; x++) {
            for(let y = 0; y*sub < Y; y++) {
                let p = this.V(20*y*sub - Y*10 + 10*sub, 0, 20*x*sub - X*10 + 10*sub);
                if(sub === 1 && sub === 1) {
                    s.asm(p, null, 'stud' + suffix);
                }
                else {
                    s.asm(p, null, 'stug' + suffix + '-' + sub + 'x' + sub);
                }
            }
        }
        return pt;
    },
    stugX: function(Y, con) {
        let [pt,s] = this.pT('Stud Tube Solid Group  1 x ' + this.pad2(Y));

        for(let i = 0; i < con.length; i+=2) {
            let p = this.V(con[i], 0, 0);
            s.asm(p, null, 'stug3-1x' + con[i+1]);
        }
        return pt;
    },
    stug2: function(suffix) {
        const NAMES = {10:'Curved',15:'Straight'};
        let [pt,s] = this.pT('Stud Group Truncated Laterally ' + NAMES[suffix] + ' 40D for Round 2 x 2 Parts');

        s.asm(this.V(-10,0,-10), this.R(-1,1), 'stud' + suffix);
        s.asm(this.V(-10,0,10), this.R2(-1,1,1), 'stud' + suffix);
        s.asm(this.V(10,0,-10), this.R2(1,1,-1), 'stud' + suffix);

        s.asm(this.V(10,0,10), null, 'stud' + suffix);

        return pt;
    },
    stug3: function(S, px1, px2, X, py, Y = 'stud', y = 1) {
        let [pt,s] = this.pT('Stud Group  ' + S + ' x  ' + S);

        s.asm(this.V(px1, 0, px2), null, 'stug-' + X + 'x' + X);
        for(let x = 0; x < (S/y)-1; x++) {
            s.asm(this.V(10*(y-S + 2*x*y), 0, py), null, Y);
        }
        for(let x = 0; x < (S/y); x++) {
            s.asm(this.V((S-y)*10, 0, 10*(y-S + 2*x*y)), null, Y);
        }
        return pt;
    },
    stug4: function(x) {
        let [pt,s] = this.pT('Stud Tube Open Group  ' + x + ' x  ' + x);
        x--;
        s.asm(this.V(-10,0,-10), null, 'stug4-' + x + 'x' + x);
        s.asm(this.V(-10,0,10*x), null, 'stug4-1x' + x);
        s.asm(this.V(10*x,0,0), this.R2(-1,1,1), 'stug4-1x' + (x+1));

        return pt;
    },
    triangle: function() {
        let [pt,s] = this.pT('Triangle');
        s.at([0,0,0,1,0,0,0,0,1]);
        s.al([0,0,0,1,0,0, 1,0,0,0,0,1, 0,0,1,0,0,0]);
        return pt;
    },
    logoPositions: [[-2,-4,2,-5,2,-3.5] // L
                    ,
                    [-2,0,-2,-2,2,-3,2,-1],[0,-1,0,-2.5], // E (Divided due to middle line)
                    ,
                    [-1.5,2.25,-2,2,-2,1,-1.5,.5,1.5,-.25,2,0,2,1,1.5,1.5,0,2,0,1] //G
                    ,
                    [-1.5,4.75,-2,4.5,-2,3.5,-1.5,3,1.5,2.25,2,2.5,2,3.5,1.5,4,-1.5,4.75] // O
                   ], // Logo positions copied from logo.dat by Paul Easter [pneaster]
    logo1: function() {
        let [pt,s] = this.pT('LEGO Logo for Studs - Non-3D Thin Lines');
        pt.ldraw_org = 'Unofficial_Primitive';

        this.logoPositions.forEach(letter => {
	    for(let i = 2; i < letter.length; i+=2) {
	        s.al([letter[i-2], 0, letter[i-1], letter[i], 0, letter[i+1]]);
	    }
        });
        return pt;
    },
    rect: function(hx, name, prefix = '') {
        let [pt,s] = this.pT('Rectangle' + (name ? (prefix + ' with ' + name) : ''));
        if(hx & 1) {
            s.aq([-1,0,1,-1,0,-1,1,0,-1,1,0,1]);
        }
        if(hx & 2) {
            s.al([1,0,1,-1,0,1]);
        }
        if(hx & 4) {
            s.al([-1,0,1,-1,0,-1]);
        }
        if(hx & 8) {
            s.al([-1,0,-1,1,0,-1]);
        }
        if(hx & 16) {
            s.al([1,0,-1,1,0,1]);
        }
        return pt;
    },
    bx: function(h1, h2, F, E) {
        let [pt,s] = this.pT('Box 6 (six faces)');
        let e = [ [1,1,1, -1,1,1], // 1
                  [-1,1,1, -1,1,-1], // 2
                  [-1,1,-1, 1,1,-1], // 4
                  [1,1,-1, 1,1,1], // 8
                  [1,-1,1, -1,-1,1], // 16
                  [-1,-1,1, -1,-1,-1], // 32
                  [-1,-1,-1, 1,-1,-1], // 64
                  [1,-1,-1, 1,-1,1], // 128
                  [1,-1,1, 1,1,1], // 256
                  [-1,-1,1, -1,1,1], // 512
                  [1,-1,-1, 1,1,-1], // 1024
                  [-1,-1,-1, -1,1,-1] ]; // 2048
        for(let i = 0, j = 1; i < e.length; i++, j*=2) {
            if(h1 & j) {
                s.al(e[i]);
            }
        }
        let nf = 0;
        let q = [ [1,1,1, 1,1,-1, -1,1,-1, -1,1,1], // 1
                  [-1,-1,-1, 1,-1,-1, 1,-1,1, -1,-1,1], // 2
                  [-1,-1,1, 1,-1,1, 1,1,1, -1,1,1], // 4
                  [-1,-1,-1, -1,-1,1, -1,1,1, -1,1,-1], // 8
                  [1,-1,-1, -1,-1,-1, -1,1,-1, 1,1,-1], // 16
                  [1,-1,1, 1,-1,-1, 1,1,-1, 1,1,1] ]; // 32
        for(let i = 0, j = 1; i < q.length; i++, j*=2) {
            if(h2 & j) {
                s.aq(q[i]);
                nf++;
            }
        }
        if(h2 !== 63) {
            pt.modelDescription = 'Box with ' + nf + F + ' Faces ' + E + ' Edges';
        }
        return pt;
    },
    bx2: function(h1, h2, F, E, G = 's') {
        let [pt,s] = this.pT('Box with ');
        let e = [ [1,1,1, -1,1,1], // 1
                  [-1,1,1, -1,1,-1], // 2
                  [-1,1,-1, 1,1,-1], // 4
                  [1,1,-1, 1,1,1], // 8
                  [1,0,1, -1,0,1], // 16
                  [-1,0,1, -1,0,-1], // 32
                  [-1,0,-1, 1,0,-1], // 64
                  [1,0,-1, 1,0,1], // 128
                  [1,0,1, 1,1,1], // 256
                  [-1,0,1, -1,1,1], // 512
                  [1,0,-1, 1,1,-1], // 1024
                  [-1,0,-1, -1,1,-1] ]; // 2048
        for(let i = 0, j = 1; i < e.length; i++, j*=2) {
            if(h1 & j) {
                s.al(e[i]);
            }
        }
        let nf = 0;
        let q = [ [ -1,1,1,   1,1,1,   1,1,-1, -1,1,-1], // 1
                  [ -1,1,1,  -1,0,1,   1,0,1,   1,1,1], // 2
                  [ -1,1,-1, -1,0,-1, -1,0,1,  -1,1,1], // 4
                  [  1,1,-1,  1,0,-1, -1,0,-1, -1,1,-1], // 8
                  [  1,1,1,   1,0,1,   1,0,-1,  1,1,-1] ]; // 16
        for(let i = 0, j = 1; i < q.length; i++, j*=2) {
            if(h2 & j) {
                s.aq(q[i]);
                nf++;
            }
        }
        pt.modelDescription += nf + F + ' Faces ' + E + ' Edge' + G;
        return pt;
    },
    tri: function(h1, h2, h3, n) {
        let [pt,s] = this.pT('Triangular Prism with ' + n);
        let e = [
            [1,1,0,0,1,1], // 1
            [0,1,1,0,1,0], // 2
            [0,1,0,1,1,0], // 4
            [1,0,0,0,0,1], // 8
            [0,0,1,0,0,0], // 16
            [0,0,0,1,0,0], // 32
            [1,0,0,1,1,0], // 64
            [0,0,1,0,1,1], // 128
            [0,0,0,0,1,0] // 256
        ];
        for(let i = 0, j = 1; i < e.length; i++, j*=2) {
            if(h1 & j) {
                s.al(e[i]);
            }
        }
        let t = [
            [0,1,0,0,1,1,1,1,0], // 1
            [1,0,0,0,0,1,0,0,0] // 2
        ];
        for(let i = 0, j = 1; i < t.length; i++, j*=2) {
            if(h2 & j) {
                s.at(t[i]);
            }
        }
        let q = [
            [1,1,0,0,1,1,0,0,1,1,0,0], // 1
            [0,1,1,0,1,0,0,0,0,0,0,1], // 2
            [0,1,0,1,1,0,1,0,0,0,0,0], // 4      
        ];
        for(let i = 0, j = 1; i < q.length; i++, j*=2) {
            if(h3 & j) {
                s.aq(q[i]);
            }
        }
        return pt;
    },
    registerAll: function() {
	const X = this;
	let R = (a,b) => X.register(a,b);

        // Rectangles:
	R('rect', () => X.rect(31));
        R('rect1', () => X.rect(17, '1 Edge'));
        R('rect2a', () => X.rect(19, '2 Adjacent Edges'));
        R('rect2p', () => X.rect(11, '2 Parallel Edges'));
        R('rect3', () => X.rect(23, '3 Edges'));
        R('recte3', () => X.rect(22, '3 Edges', ' Empty'));
        R('recte4', () => X.rect(30, '4 Edges', ' Empty'));
        // Boxes:
        R('box', () => X.bx(4095, 63));
        R('box0', () => X.bx(4095, 0, '', 'and All'));
        R('box2-5', () => X.bx(799, 5, '', 'without 5'));
        R('box2-7', () => X.bx(779, 5, '', 'without 7'));
        R('box2-9', () => X.bx(265, 5, '', 'without 9'));
        R('box2-9p', () => X.bx(21, 5, '', 'with 3 Parallel'));
        R('box2-11', () => X.bx(1, 5, '', 'without 11'));
        R('box3-3', () => X.bx(1951, 37, ' Adjacent', 'and 3 Missing'));
        R('box3-5a', () => X.bx(923, 37, ' Adjacent', 'without 5 Adjacent'));
        R('box3-7a', () => X.bx(409, 37, ' Adjacent', 'without 7 Adjacent'));
        R('box3-9a', () => X.bx(265, 37, ' Adjacent', 'without 9 Adjacent'));
        R('box3-12', () => X.bx(0, 37, ' Adjacent', 'without Any'));
        R('box3#8p', () => X.eAlias());
        R('box3u2p', () => X.bx2(3935, 11, '', 'without 2 Parallel'));
	R('box3u4a', () => X.bx2(3855, 11, '', 'without 4 Adjacent'));
	R('box3u4p', () => X.bx2(3925, 11, '', 'without 4 Parallel'));
        R('box3u5p', () => X.bx2(2647, 11, '', 'without 5'));
	R('box3u6', () => X.bx2(1365, 11, '', 'without 6'));
	R('box3u7a', () => X.bx2(2567, 11, '', 'without 7 Adjacent'));
	R('box3u8p', () => X.bx2(85, 11, '', 'and 4 Parallel'));
        R('box3u10p', () => X.bx2(5, 11, '', 'without 10 Parallel'));
        R('box3u12', () => X.bx2(0, 11, ' Parallel', 'without Any'));
	R('box4', () => X.bx2(4095, 30, '', '(2 Parallel Pairs) and All'));
        R('box4t', () => X.bx2(4095, 23, ' Adjacent', 'and All'));
        R('box4-1', () => X.bx2(4031, 23, '', 'without 1', ''));
        R('box4-2p', () => X.bx2(4015, 23, '', 'without 2 Parallel'));
        R('box4-3p', () => X.bx2(4011, 23, '', 'without 3 Parallel'));
        R('box4-4a', () => X.bx2(955, 23, '', 'without 4 Adjacent'));
        R('box4o4a', () => X.bx2(4080, 30, '', '(2 Parallel Pairs) without Bottom'));
        R('box4-5a', () => X.bx2(3851, 23, '', 'without 5'));
        R('box4-7a', () => X.bx2(779, 23, '', 'without 7 Adjacent'));
        R('box4o8a', () => X.bx2(3840, 30, '', '(2 Parallel Pairs) without Top and Bottom'));
        R('box4-12', () => X.bx2(0, 23, '', 'without Any'));
        R('box5', () => X.bx2(4095, 31, '', 'and All'));
        R('box5-1', () => X.bx2(4031, 31, '', 'without 1', ''));
        R('box5-2p', () => X.bx2(4015, 31, '', 'without 2 Parallel'));
        R('box5-4a', () => X.bx2(3855, 31, '', 'without 4 Adjacent'));
        R('box5-12', () => X.bx2(0, 31, '', 'without Any'));
        // Triangular prisms;
        R('tri3', () => X.tri(511, 0, 7, '2 Square Faces and 1 Rectangular Face'));
        R('tri3-1', () => X.tri(503, 0, 7, '2 Square Faces and 1 Rectangular Face without 1 Edge'));
        R('tri3-3', () => X.tri(455, 0, 7, '2 Square Faces and 1 Rectangular Face without 3 Edges'));
        R('tri3a1', () => X.tri(503, 1, 6, '3 Adjacent Faces without 1 Edge'));
        R('tri3a4', () => X.tri(310, 1, 6, '3 Adjacent Faces without 4 Edges'));
        R('tri3u1', () => X.tri(255, 3, 1, '3 Faces without 1 Edge'));
        R('tri3u3', () => X.tri(237, 3, 1, '3 Faces without 3 Edges'));
        R('tri4', () => X.tri(511, 3, 6, '2 Square Faces and 2 Triangular Faces'));
        // Circular line segments:
        R('?-?edge', (a,b) => X.ed(a,b));
        R('48\\?-?edge', (a,b) => X.e48(a, b));
        //R('48\\2-4edge', () => X.e48(2, 4)); // TODO Fix: Inconsistent slash in official LDraw file
        //R('48\\4-4edge', () => X.e48(4, 4)); // TODO Fix: -||-
        // Cylinders with conditional lines:
        R('?-?cyli', (a,b) => X.cy(a, b));
        R('1-4cyli', () => X.cy(1, 4, 0)); // For some files the test points of conditional lines are at y=0 instead of y=1
        R('4-4cyli', () => X.cy(4, 4, 0)); // y=0
        R('7-8cyli', () => X.cy(7, 8, 1, 1)); // Special dist=1 to control points
        R('7-16cyli', () => X.cy(7, 16, 1, 1)); // Special dist=1 to control points
        R('48\\?-?cyli', (a,b) => X.c48(a, b));
        // Cylinders without conditional lines:
        R('?-?cyli2', (a,b) => X.cy2(a, b));
        R('48\\?-?cyli2', (a,b) => X.cy2(a, b, 3));
        // Cylinders with open ends:
        R('?-?cylo', (a,b) => X.co(a, b));
        R('48\\?-?cylo', (a,b) => X.co48(a, b));
        // Cylinders with closed ends:
        R('?-4cylc', a => X.cc(a));
        R('48\\?-4cylc', a => X.cc48(a));

        R('1-4cylc2', () => X.ccX(1, 1, 2, ' '));
        R('4-4cylc2', () => X.ccX(4));
        R('48\\4-4cylc2', () => X.ccX(4, 3));

        R('?-4cylc3', a => X.ccX(a, 1, ''));
        R('48\\4-4cylc3', a => X.ccX(a, 3, ''));

        // TODO Cylinder truncated by an angled plane:
        R('1-4cyls', () => X.cylSloped(1, X.V(-1, 0, 1)));
        R('2-4cyls', () => X.cylSloped(2, X.V(-1, 0, -1)));
        R('4-4cyls', () => X.cylSloped(4));
        // TODO *cyls2
        // TODO Cylinder truncated by another cylinder cylj*.dat
        // TODO Torus t*i*.dat
        // TODO Torus t*o*.dat
        // TODO Torus t*q*.dat
        // TODO Reverse ratio torus r*o*.dat
        // TODO Sphere section *sphe.dat

        // Discs
        R('?-?disc', (a,b) => X.disc(a, b));
        R('48\\?-?disc', (a,b) => X.d48(a, b));

        // Inverse of circular disc sectors:
        R('?-?ndis', (a,b) => X.nd(a, b));
        R('48\\?-?ndis', (a,b) => X.n48(a, b));

        // TODO Circular disc segment:
        R('1-16chrd', () => X.eAlias('Chord 0.0625'));
        R('13-16chr', () => X.alias('13-16chrd'));
        //'1-4chrd': X => X.chrd(1, 4), 
        // TODO: The chrd primitives are fairly inconsistent and will require composed polygon comparisons!
        // TODO: All cones:
        R('1-4con0', () => X.con0(1));
        R('1-4con1', () => X.con(1, 4, 1, 1, -.4142, -.4142, 1));
	//'1-4con40': X => X.con(1, 4, 40, 36.956, 1, -16.568, 40),

        R('1-8con0', () => X.con0(1, 8));

        R('1-16con1', () => X.con(1, 16, 1, .92388, -.382683, .7071, .7071));

        R('2-4con0', () => X.con0(2));
        R('2-4con1', () => X.con(2, 4, 1, 1, -.4142, -1, -.4142));
        
        R('4-4con0', () => X.con0(4));
        R('4-4con?', a => X.con(4, 4, a));

        // Rings:
        R('?-?ring?', (a,b,c) => X.ri(a, b, c));
        R('?-?rin?', (a,b,c) => X.ri(a, b, c));
        R('ring?', a => X.alias('4-4ring'+a));
        R('ring10', () => X.alias('4-4rin10'));
        R('48\\?-?rin?', (a,b,c) => X.r48(a, b, c));
        R('48\\?-?ring?', (a,b,c) => X.r48(a, b, c));
	R('?-?ri?', (a,b,c) => X.alias(a+'-'+b+'ring'+c));

        // Stud groups (TODO Duplo):
        R('stug-?x?', (a,b) => X.stug(a, b));
        R('stug-4x4', () => X.stug(4, 4, '', 2));
        R('stug-5x5', () => X.stug3(5, -10, -10, 4, 40));
        R('stug-6x6', () => X.stug(6, 6, '', 3));
        R('stug-7x7', () => X.stug3(7, -10, 10, 6, -60));
        R('stug-8x8', () => X.stug(8, 8, '', 4));
        R('stug-9x9', () => X.stug3(9, -30, -30, 6, 60, 'stug-3x3', 3));
        R('stug-12x12', () => X.stug(12, 12, '', 6));
        R('stug-16x16', () => X.stug(16, 16, '', 8));
        R('stug?', a => X.alias('stug-'+a+'x'+a));
        R('stug2-?x?', (a,b) => X.stug(a, b, '2'));
        R('stug3-?x?', (a,b) => X.stug(a, b, '3'));
        R('stug3-1x11', (a,b) => X.stugX(11, [-50,6,60,5]));
        R('stug4-?x?', (a,b) => X.stug(a, b, '4'));
        R('stug2-4x4', () => X.stug(4, 4, '2', 2));
        R('stug2a', () => X.alias('stug2-2x2'));

        R('stug4-4x4', () => X.stug(4, 4, '4', 2));
        R('stug4-5x5', () => X.stug4(5));
        R('stug4-6x6', () => X.stug(6, 6, '4', 3));
        R('stug4-7x7', () => X.stug4(7));
        R('stug4a', () => X.alias('stug2-4x4'));
        R('stug10-2x2', () => X.stug2(10));
        R('stug15-2x2', () => X.stug2(15));
        R('stugp01-1x3', () => X.stug(1, 3, 'p01'));
        R('stugp01-1x4', () => X.stug(1, 4, 'p01'));
        R('stugp01-1x6', () => X.stug(1, 6, 'p01'));
        R('stugp01-1x10', () => X.stug(1, 10, 'p01'));

	R('stu2-logo', () => X.alias('8/stud-logo'));
	R('stu2-logo?', a => X.alias('8/stud-logo'+a));
	R('stu22-logo', () => X.alias('8/stud2-logo'));
	R('stu22-logo?', a => X.alias('8/stud2-logo'+a));
	R('stu219', () => X.alias('8/stud19'));
	R('stu224', () => X.alias('8/stud24'));
	R('stu227', () => X.alias('8/stud27'));
	R('stu227a', () => X.alias('8/stud27a'));
	R('stu228', () => X.alias('8/stud28'));
	R('stu24f1n', () => X.alias('8/stud4f1n'));

        // Commonly used misc. part types:
        R('logo', () => X.logo1());
        R('empty', () => X.empty());
        R('triangle', () => X.triangle());
    },
    path: {} // token (char or number) -> next. Invoke '!' to build part type
};

LDR.Generator.registerAll();

// Helper functions for steps:
THREE.LDRStep.prototype.al = function(x) {
    for(let i = 0; i < x.length; i+=6) {
	this.addLine(24,
		     LDR.Generator.V(x[i], x[i+1], x[i+2]),
		     LDR.Generator.V(x[i+3], x[i+4], x[i+5]));
    }
}
THREE.LDRStep.prototype.at = function(t) {
    for(let i = 0; i < t.length; i+=9) {
	this.addTriangle(16,
		         LDR.Generator.V(t[i], t[i+1], t[i+2]),
		         LDR.Generator.V(t[i+3], t[i+4], t[i+5]),
		         LDR.Generator.V(t[i+6], t[i+7], t[i+8]));
    }
}
THREE.LDRStep.prototype.aq = function(q) {
    for(let i = 0; i < q.length; i+=12) {
	this.addQuad(16,
		     LDR.Generator.V(q[i], q[i+1], q[i+2]),
		     LDR.Generator.V(q[i+3], q[i+4], q[i+5]),
		     LDR.Generator.V(q[i+6], q[i+7], q[i+8]),
		     LDR.Generator.V(q[i+9], q[i+10], q[i+11]));
    }
}
THREE.LDRStep.prototype.asm = function(p = null, r = null, id = '', c = 16, cull = true, ccw = false) {
    if(p === null) {
        p = LDR.Generator.V(0, 0, 0);
    }
    if(r === null) {
        r = LDR.Generator.R(1, 1);
    }
    this.addSubModel(new THREE.LDRPartDescription(c, p, r, id+'.dat', cull, ccw));
}
